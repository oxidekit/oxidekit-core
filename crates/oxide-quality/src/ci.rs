//! CI/CD integration helpers
//!
//! Generates CI/CD configurations for popular platforms.

use crate::CiConfig;
use serde::{Deserialize, Serialize};
use std::path::Path;

/// Generate CI configuration
pub fn generate_ci_config(project_path: &Path, config: &CiConfig) -> CiGenerationResult {
    let mut result = CiGenerationResult::new();

    if config.github_actions {
        result.github_actions = Some(generate_github_actions(config));
    }

    if config.gitlab_ci {
        result.gitlab_ci = Some(generate_gitlab_ci(config));
    }

    result
}

/// CI generation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CiGenerationResult {
    /// GitHub Actions workflow content
    pub github_actions: Option<String>,
    /// GitLab CI config content
    pub gitlab_ci: Option<String>,
    /// Files to create
    pub files: Vec<CiFile>,
}

impl CiGenerationResult {
    pub fn new() -> Self {
        Self {
            github_actions: None,
            gitlab_ci: None,
            files: Vec::new(),
        }
    }

    /// Save generated files
    pub fn save(&self, project_path: &Path) -> Result<Vec<String>, std::io::Error> {
        let mut created = Vec::new();

        if let Some(ref gh) = self.github_actions {
            let dir = project_path.join(".github/workflows");
            std::fs::create_dir_all(&dir)?;

            let path = dir.join("quality-gates.yml");
            std::fs::write(&path, gh)?;
            created.push(path.to_string_lossy().to_string());
        }

        if let Some(ref gl) = self.gitlab_ci {
            let path = project_path.join(".gitlab-ci.yml");
            std::fs::write(&path, gl)?;
            created.push(path.to_string_lossy().to_string());
        }

        Ok(created)
    }
}

impl Default for CiGenerationResult {
    fn default() -> Self {
        Self::new()
    }
}

/// CI file to create
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CiFile {
    /// File path relative to project root
    pub path: String,
    /// File content
    pub content: String,
}

/// Generate GitHub Actions workflow
fn generate_github_actions(config: &CiConfig) -> String {
    let report_format = match config.report_format {
        crate::ReportFormat::Json => "json",
        crate::ReportFormat::Markdown => "markdown",
        crate::ReportFormat::Text => "text",
    };

    let fail_on_warnings = if config.fail_on_warnings {
        "      - name: Check for warnings\n        run: |\n          if [ $(jq '.summary.total_warnings' quality-report.json) -gt 0 ]; then\n            echo \"Warnings found, failing build\"\n            exit 1\n          fi\n"
    } else {
        ""
    };

    let upload_step = if config.upload_reports {
        r#"      - name: Upload quality report
        uses: actions/upload-artifact@v4
        with:
          name: quality-report
          path: quality-report.*
          retention-days: 30
"#
    } else {
        ""
    };

    let pr_comment = if config.pr_comments {
        r#"      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('quality-report.json', 'utf8'));

            const status = report.status === 'passed' ? ':white_check_mark:' : ':x:';
            const body = `## Quality Gates ${status}

            **Status:** ${report.status}
            **Errors:** ${report.summary.total_errors}
            **Warnings:** ${report.summary.total_warnings}
            **Duration:** ${report.total_duration_ms}ms

            <details>
            <summary>Details</summary>

            \`\`\`json
            ${JSON.stringify(report.sections, null, 2).substring(0, 5000)}
            \`\`\`
            </details>`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
"#
    } else {
        ""
    };

    format!(
        r#"# OxideKit Quality Gates
# Generated by oxide-quality

name: Quality Gates

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master, develop]

env:
  CARGO_TERM_COLOR: always

jobs:
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-action@stable
        with:
          components: clippy, rustfmt

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{{{ runner.os }}}}-cargo-${{{{ hashFiles('**/Cargo.lock') }}}}

      - name: Install oxide CLI
        run: cargo install --path crates/oxide-cli

      - name: Run quality gates
        run: |
          oxide check --format {report_format} --output quality-report.{report_format}
          oxide check --format json --output quality-report.json

{fail_on_warnings}
{upload_step}
{pr_comment}
      - name: Fail on errors
        if: failure()
        run: |
          echo "Quality gates failed"
          cat quality-report.{report_format}
          exit 1

  lint:
    name: Lint
    runs-on: ubuntu-latest
    needs: quality-gates

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-action@stable
        with:
          components: clippy

      - name: Cargo clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

  format:
    name: Format
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-action@stable
        with:
          components: rustfmt

      - name: Cargo fmt
        run: cargo fmt --all -- --check

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: quality-gates

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-action@stable

      - name: Run tests
        run: cargo test --all-features

  a11y:
    name: Accessibility
    runs-on: ubuntu-latest
    needs: quality-gates

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-action@stable

      - name: Install oxide CLI
        run: cargo install --path crates/oxide-cli

      - name: Run accessibility checks
        run: oxide a11y check --strict

  security:
    name: Security Audit
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Audit dependencies
        uses: rustsec/audit-check@v1
        with:
          token: ${{{{ secrets.GITHUB_TOKEN }}}}

      - uses: dtolnay/rust-action@stable

      - name: Install oxide CLI
        run: cargo install --path crates/oxide-cli

      - name: Run security checks
        run: oxide audit

  bundle:
    name: Bundle Size
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-action@stable

      - name: Build release
        run: cargo build --release

      - name: Install oxide CLI
        run: cargo install --path crates/oxide-cli

      - name: Check bundle size
        run: oxide bundle check

      - name: Report bundle size
        uses: actions/github-script@v7
        with:
          script: |
            const {{ execSync }} = require('child_process');
            const size = execSync('oxide bundle size --format json').toString();
            const data = JSON.parse(size);

            const body = `## Bundle Size Report

            | Metric | Value |
            |--------|-------|
            | Total Size | ${{data.total_size_formatted}} |
            | Limit | ${{data.size_limit_formatted}} |
            | Status | ${{data.passed ? 'OK' : 'EXCEEDED'}} |`;

            await github.rest.issues.createComment({{
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            }});
"#,
        report_format = report_format,
        fail_on_warnings = fail_on_warnings,
        upload_step = upload_step,
        pr_comment = pr_comment
    )
}

/// Generate GitLab CI config
fn generate_gitlab_ci(config: &CiConfig) -> String {
    let report_format = match config.report_format {
        crate::ReportFormat::Json => "json",
        crate::ReportFormat::Markdown => "markdown",
        crate::ReportFormat::Text => "text",
    };

    let artifacts = if config.upload_reports {
        r#"  artifacts:
    paths:
      - quality-report.*
    expire_in: 30 days
    reports:
      codequality: quality-report.json
"#
    } else {
        ""
    };

    format!(
        r#"# OxideKit Quality Gates
# Generated by oxide-quality

image: rust:latest

stages:
  - quality
  - lint
  - test
  - security
  - build

variables:
  CARGO_HOME: $CI_PROJECT_DIR/.cargo
  RUSTFLAGS: "-D warnings"

cache:
  key: $CI_COMMIT_REF_SLUG
  paths:
    - .cargo/
    - target/

quality-gates:
  stage: quality
  script:
    - cargo install --path crates/oxide-cli
    - oxide check --format {report_format} --output quality-report.{report_format}
    - oxide check --format json --output quality-report.json
{artifacts}

lint:
  stage: lint
  script:
    - rustup component add clippy
    - cargo clippy --all-targets --all-features -- -D warnings
  needs:
    - quality-gates

format:
  stage: lint
  script:
    - rustup component add rustfmt
    - cargo fmt --all -- --check
  allow_failure: true

test:
  stage: test
  script:
    - cargo test --all-features
  needs:
    - lint
  coverage: '/^\d+.\d+% coverage/'

a11y:
  stage: test
  script:
    - cargo install --path crates/oxide-cli
    - oxide a11y check --strict
  needs:
    - quality-gates

security:
  stage: security
  script:
    - cargo install cargo-audit
    - cargo audit
    - cargo install --path crates/oxide-cli
    - oxide audit
  allow_failure: true

build:
  stage: build
  script:
    - cargo build --release
  needs:
    - test
  artifacts:
    paths:
      - target/release/
    expire_in: 1 week

bundle-check:
  stage: build
  script:
    - cargo build --release
    - cargo install --path crates/oxide-cli
    - oxide bundle check
  only:
    - merge_requests
"#,
        report_format = report_format,
        artifacts = artifacts
    )
}

/// Generate minimal CI config for quick setup
pub fn generate_minimal_ci() -> String {
    r#"# OxideKit Quality Gates (Minimal)

name: Quality

on: [push, pull_request]

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-action@stable
      - run: cargo install --path crates/oxide-cli
      - run: oxide check
      - run: cargo test
"#.to_string()
}

/// CI status badge generator
pub fn generate_badge_url(platform: &str, repo: &str) -> String {
    match platform {
        "github" => format!(
            "https://github.com/{}/actions/workflows/quality-gates.yml/badge.svg",
            repo
        ),
        "gitlab" => format!(
            "https://gitlab.com/{}/badges/main/pipeline.svg",
            repo
        ),
        _ => String::new(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_github_actions_generation() {
        let config = CiConfig::default();
        let workflow = generate_github_actions(&config);

        assert!(workflow.contains("Quality Gates"));
        assert!(workflow.contains("oxide check"));
        assert!(workflow.contains("cargo clippy"));
    }

    #[test]
    fn test_gitlab_ci_generation() {
        let config = CiConfig::default();
        let ci = generate_gitlab_ci(&config);

        assert!(ci.contains("stages:"));
        assert!(ci.contains("oxide check"));
        assert!(ci.contains("cargo audit"));
    }

    #[test]
    fn test_badge_url() {
        let badge = generate_badge_url("github", "oxidekit/oxidekit");
        assert!(badge.contains("github.com"));
        assert!(badge.contains("badge.svg"));
    }
}
