//! Pre-commit hook generation
//!
//! Generates and manages Git pre-commit hooks for quality gates.

use serde::{Deserialize, Serialize};
use std::path::Path;

/// Hook configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HookConfig {
    /// Enable lint checks
    #[serde(default = "default_true")]
    pub lint: bool,

    /// Enable format checks
    #[serde(default = "default_true")]
    pub format: bool,

    /// Enable accessibility checks
    #[serde(default)]
    pub a11y: bool,

    /// Enable type checking
    #[serde(default = "default_true")]
    pub typecheck: bool,

    /// Enable tests (can be slow)
    #[serde(default)]
    pub test: bool,

    /// Only check staged files
    #[serde(default = "default_true")]
    pub staged_only: bool,

    /// Allow commit with warnings
    #[serde(default = "default_true")]
    pub allow_warnings: bool,

    /// Bypass flag name
    #[serde(default = "default_bypass")]
    pub bypass_flag: String,
}

impl Default for HookConfig {
    fn default() -> Self {
        Self {
            lint: true,
            format: true,
            a11y: false,
            typecheck: true,
            test: false,
            staged_only: true,
            allow_warnings: true,
            bypass_flag: "SKIP_HOOKS".to_string(),
        }
    }
}

fn default_true() -> bool { true }
fn default_bypass() -> String { "SKIP_HOOKS".to_string() }

/// Generate pre-commit hook
pub fn generate_pre_commit_hook(config: &HookConfig) -> String {
    let mut checks = Vec::new();

    if config.format {
        checks.push(generate_format_check(config));
    }

    if config.lint {
        checks.push(generate_lint_check(config));
    }

    if config.a11y {
        checks.push(generate_a11y_check(config));
    }

    if config.typecheck {
        checks.push(generate_typecheck(config));
    }

    if config.test {
        checks.push(generate_test_check(config));
    }

    let bypass_check = format!(
        r#"# Check for bypass flag
if [ -n "${{{}}}" ]; then
    echo "Skipping pre-commit hooks (bypass flag set)"
    exit 0
fi
"#,
        config.bypass_flag
    );

    format!(
        r#"#!/bin/bash
# OxideKit Quality Gates Pre-commit Hook
# Generated by oxide-quality
#
# To bypass: {}=1 git commit -m "message"
# To uninstall: rm .git/hooks/pre-commit

set -e

{}

echo "Running pre-commit quality checks..."
echo ""

{}

echo ""
echo "All pre-commit checks passed!"
"#,
        config.bypass_flag,
        bypass_check,
        checks.join("\n\n")
    )
}

/// Generate format check
fn generate_format_check(config: &HookConfig) -> String {
    let file_filter = if config.staged_only {
        r#"STAGED_RS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.rs$' || true)
if [ -z "$STAGED_RS_FILES" ]; then
    echo "  No Rust files to format"
else
    echo "$STAGED_RS_FILES" | xargs cargo fmt -- --check"#
    } else {
        "cargo fmt --all -- --check"
    };

    format!(
        r#"# Format check
echo "Checking code formatting..."
{}
echo "  Format: OK"
"#,
        file_filter
    )
}

/// Generate lint check
fn generate_lint_check(config: &HookConfig) -> String {
    let warning_flag = if config.allow_warnings {
        ""
    } else {
        " -D warnings"
    };

    let oui_check = if config.staged_only {
        r#"STAGED_OUI_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.oui$' || true)
if [ -n "$STAGED_OUI_FILES" ]; then
    echo "  Checking .oui files..."
    oxide lint $STAGED_OUI_FILES
fi"#
    } else {
        "oxide lint"
    };

    format!(
        r#"# Lint check
echo "Running linters..."

# Rust lint
cargo clippy --all-targets --all-features --{warning_flag}
echo "  Clippy: OK"

# OUI lint
{oui_check}
echo "  OUI lint: OK"
"#,
        warning_flag = warning_flag,
        oui_check = oui_check
    )
}

/// Generate accessibility check
fn generate_a11y_check(_config: &HookConfig) -> String {
    r#"# Accessibility check
echo "Running accessibility checks..."
oxide a11y check
echo "  A11y: OK"
"#.to_string()
}

/// Generate type check
fn generate_typecheck(_config: &HookConfig) -> String {
    r#"# Type check
echo "Running type check..."
cargo check --all-targets --all-features
echo "  Type check: OK"
"#.to_string()
}

/// Generate test check
fn generate_test_check(config: &HookConfig) -> String {
    let test_filter = if config.staged_only {
        "# Run tests related to changed files\ncargo test --all-features -- --test-threads=1"
    } else {
        "cargo test --all-features"
    };

    format!(
        r#"# Test check
echo "Running tests..."
{}
echo "  Tests: OK"
"#,
        test_filter
    )
}

/// Install pre-commit hook
pub fn install_hook(project_path: &Path, config: &HookConfig) -> Result<(), std::io::Error> {
    let hooks_dir = project_path.join(".git/hooks");

    if !hooks_dir.exists() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "Not a git repository (no .git/hooks directory)",
        ));
    }

    let hook_path = hooks_dir.join("pre-commit");
    let hook_content = generate_pre_commit_hook(config);

    // Backup existing hook if present
    if hook_path.exists() {
        let backup_path = hooks_dir.join("pre-commit.backup");
        std::fs::copy(&hook_path, &backup_path)?;
    }

    std::fs::write(&hook_path, hook_content)?;

    // Make executable on Unix
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = std::fs::metadata(&hook_path)?.permissions();
        perms.set_mode(0o755);
        std::fs::set_permissions(&hook_path, perms)?;
    }

    Ok(())
}

/// Uninstall pre-commit hook
pub fn uninstall_hook(project_path: &Path) -> Result<(), std::io::Error> {
    let hook_path = project_path.join(".git/hooks/pre-commit");

    if hook_path.exists() {
        // Check if it's our hook
        let content = std::fs::read_to_string(&hook_path)?;
        if content.contains("OxideKit Quality Gates") {
            std::fs::remove_file(&hook_path)?;

            // Restore backup if exists
            let backup_path = project_path.join(".git/hooks/pre-commit.backup");
            if backup_path.exists() {
                std::fs::rename(&backup_path, &hook_path)?;
            }
        } else {
            return Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Pre-commit hook exists but is not managed by OxideKit",
            ));
        }
    }

    Ok(())
}

/// Generate commit-msg hook for conventional commits
pub fn generate_commit_msg_hook() -> String {
    r#"#!/bin/bash
# OxideKit Conventional Commits Hook
# Generated by oxide-quality

COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Conventional commit pattern
PATTERN="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .{1,72}"

if ! echo "$COMMIT_MSG" | grep -qE "$PATTERN"; then
    echo "ERROR: Commit message does not follow conventional commits format."
    echo ""
    echo "Expected format: <type>(<scope>): <description>"
    echo ""
    echo "Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert"
    echo ""
    echo "Examples:"
    echo "  feat(ui): add dark mode toggle"
    echo "  fix(parser): handle empty input"
    echo "  docs: update README"
    echo ""
    exit 1
fi

echo "Commit message format: OK"
"#.to_string()
}

/// Generate pre-push hook
pub fn generate_pre_push_hook(config: &HookConfig) -> String {
    format!(
        r#"#!/bin/bash
# OxideKit Pre-push Hook
# Generated by oxide-quality

set -e

# Check for bypass flag
if [ -n "${{{}}}" ]; then
    echo "Skipping pre-push hooks (bypass flag set)"
    exit 0
fi

echo "Running pre-push checks..."

# Full test suite
echo "Running full test suite..."
cargo test --all-features
echo "  Tests: OK"

# Full quality check
echo "Running quality gates..."
oxide check
echo "  Quality: OK"

# Security audit
echo "Running security audit..."
oxide audit || echo "  Security: WARNING (continuing...)"

echo ""
echo "All pre-push checks passed!"
"#,
        config.bypass_flag
    )
}

/// Husky-style hook configuration for package.json projects
pub fn generate_husky_config() -> String {
    r#"{
  "hooks": {
    "pre-commit": "oxide lint && oxide fmt --check",
    "pre-push": "oxide check && cargo test",
    "commit-msg": "oxide commit-msg"
  }
}
"#.to_string()
}

/// Generate lefthook configuration
pub fn generate_lefthook_config() -> String {
    r#"# OxideKit Quality Gates
# Lefthook configuration

pre-commit:
  parallel: true
  commands:
    format:
      glob: "*.rs"
      run: cargo fmt -- --check
    lint-rs:
      glob: "*.rs"
      run: cargo clippy --all-targets -- -D warnings
    lint-oui:
      glob: "*.oui"
      run: oxide lint {staged_files}

pre-push:
  commands:
    test:
      run: cargo test --all-features
    quality:
      run: oxide check

commit-msg:
  commands:
    validate:
      run: oxide commit-msg {1}
"#.to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_pre_commit() {
        let config = HookConfig::default();
        let hook = generate_pre_commit_hook(&config);

        assert!(hook.contains("#!/bin/bash"));
        assert!(hook.contains("OxideKit Quality Gates"));
        assert!(hook.contains("cargo fmt"));
        assert!(hook.contains("cargo clippy"));
    }

    #[test]
    fn test_bypass_flag() {
        let mut config = HookConfig::default();
        config.bypass_flag = "NO_HOOKS".to_string();

        let hook = generate_pre_commit_hook(&config);
        assert!(hook.contains("NO_HOOKS"));
    }

    #[test]
    fn test_commit_msg_hook() {
        let hook = generate_commit_msg_hook();
        assert!(hook.contains("conventional"));
        assert!(hook.contains("feat|fix|docs"));
    }

    #[test]
    fn test_lefthook_config() {
        let config = generate_lefthook_config();
        assert!(config.contains("pre-commit:"));
        assert!(config.contains("oxide lint"));
    }
}
